# -*- coding: utf-8 -*-
"""Nested decomposition method-stochastic programming.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TiHwpxStpx5rEcbDIHVhG9HlNw5IjLub
"""

pip install pulp

import numpy as np
import pandas as pd
from pulp import *

K=2 # number of scenario
T=4 #number of stage
# Create the model
coef=np.full([8,4],0,dtype=object)
f_cut=np.full([8,4],0,dtype=object)
opt_cut=np.full([8,4],0,dtype=object)
NLDS=np.full([4,8],0,dtype=object)
first_iteration=np.full([8,4],0,dtype=object)

#bayad t and k check shavand. az payin gereftam
for t in np.arange(1,(2**(T-1))+1):
  for k in np.arange(1,(2**T)+1):
    NLDS[t,k] = LpProblem(name="NLDS", sense=LpMinimize)



# Initialize the decision variables
n=[1,2]
xt1={i:LpVariable(cat=LpContinuous, lowBound=0, name="x[{0}]".format(i)) for i in n }
xt1 = list(xt1.values())
xt1=np.array(xt1)
xt2={(i,s1):LpVariable(cat=LpContinuous, lowBound=0, name="x[{0},{1}]".format(i,s1)) for i in n for s1 in n}
xt2 = list(xt2.values())
xt2=np.array(xt2)
xt3={(i,s1,s2):LpVariable(cat=LpContinuous, lowBound=0, name="x[{0},{1},{2}]".format(i,s1,s2)) for i in n for s1 in n for s2 in n}
xt3 = list(xt3.values())
xt3=np.array(xt3)
w={(s1,s2,s3):LpVariable(cat=LpContinuous, lowBound=0, name="w[{0},{1},{2}]".format(s1,s2,s3)) for s1 in n for s2 in n for s3 in n}
y={(s1,s2,s3):LpVariable(cat=LpContinuous, lowBound=0, name="y[{0},{1},{2}]".format(s1,s2,s3)) for s1 in n for s2 in n for s3 in n}
teta={(k,t):LpVariable(cat=LpContinuous, lowBound=0, name="teta[{0},{1}]".format(k,t)) for k in range(0,8) for t in range(0,8)}
        
#s.t.
coef[1,1] = LpConstraint('x[1] +x[2] = 55 ')
coef[2,1] = LpConstraint('-1.25*x[1]-1.14*x[2]+x[1,1]+x[2,1] = 0')
coef[2,2] = LpConstraint('-1.06*x[1]-1.12*x[2]+x[1,2]+x[2,2] = 0 ')
coef[3,1] = LpConstraint('-1.25*x[1,1]-1.14*x[2,1]+x[1,1,1]+x[2,1,1] = 0')
coef[3,2] = LpConstraint('-1.06*x[1,1]-1.12*x[2,1]+x[1,1,2]+x[2,1,2] = 0 ')
coef[3,3] = LpConstraint('-1.25*x[1,2]-1.14*x[2,2]+x[1,2,1]+x[2,2,1] = 0')
coef[3,4] = LpConstraint('-1.06*x[1,2]-1.12*x[2,2]+x[1,2,2]+x[2,2,2] = 0 ')
coef[4,1] = LpConstraint('1.25*x[1,1,1]+1.14*x[2,1,1]-y[1,1,1]+w[1,1,1] =80 ') 
coef[4,2] = LpConstraint('1.06*x[1,1,1]+1.12*x[2,1,1]-y[1,1,2]+w[1,1,2] =80 ')
coef[4,3] = LpConstraint('1.25*x[1,1,2]+1.14*x[2,1,2]-y[1,2,1]+w[1,2,1] =80')
coef[4,4] = LpConstraint('1.06*x[1,1,2]+1.12*x[2,1,2]-y[1,2,2]+w[1,2,2] =80')
coef[4,5] = LpConstraint('1.25*x[1,2,1]+1.14*x[2,2,1]-y[2,1,1]+w[2,1,1] =80')
coef[4,6] = LpConstraint('1.06*x[1,2,1]+1.12*x[2,2,1]-y[2,1,2]+w[2,1,2] =80')
coef[4,7] = LpConstraint('1.25*x[1,2,2]+1.14*x[2,2,2]-y[2,2,1]+w[2,2,1] =80')
coef[4,8] = LpConstraint('1.06*x[1,2,2]+1.12*x[2,2,2]-y[2,2,2]+w[2,2,2] =80')

NLDS[t,k] += coef[t,k]

#structures and parameters of the model
teta = np.full([K,4],0)
π = np.full([K,4],0)
E = np.full(4,0)
e = np.full(4,0)
ρ = np.full([K,4],0)
d = np.full([K,4],0)
σ = np.full([K,4],0)
D = np.full([K,4],0)
h=np.zeros(4,4)
h[1,1]= 55
h[1,2]= np.transpose([0,0])
h[2,2]= np.transpose([0,0])
h[1,3]= h[2,3]=h[3,3]=h[4,3]=np.transpose([0,0,0,0])
h[4,4]= h[2,4]=h[3,4]=h[4,4]=h[5,4]=h[6,4]=h[7,4]=h[8,4]=np.full([1,8],80)

T[1,1]= [[-1.25,-1.14],
        [0,0]]
T[2,1]= [[0,0],
        [-1.06,-1.12]]
T[1,2]= T[3,2] = [[-1.25,-1.14],[0,0],[1.25,1.14],[0.0]]
T[2,2]= T[4,2] = [[0,0],[-1.06,-1.12],[0,0],[-1.06,-1.12]]
T[1,3] = T[3,3] = T[5,3] = [[1.25,1.14],[0,0],[1.25,1.14],[0.0]]
T[2,3]= T[4,3]= T[6,3] = T[8,3] = [[0,0],[1.06,1.12],[0,0],[1.06,1.12]]
p[1,1]=1
p[:,2]=[[0.5],[0.5]]
p[:,3]= [[0.25],[0.25],[0.25],[0.25]]
p[:,4]=[[0.125],[0.125],[0.125],[0.125],[0.125],[0.125],[0.125],[0.125]]

#iteration of periods
direction="forward"
t=1
j=0
i=0
while t<=4:
    if t==1:
        x=xt1
    elif t==2:
        x=xt2
    elif t==3:
        x=xt3
    else:
        continue
    if t==2 and (E*np.transpose(x.value()) + teta[k,t]) >= e :
        break #end of algorithm
    else:   
        while j>0 :#feasible cut counter
            
            while i>0 : #optimal cut counter
                
                for k in np.arange(1,(2**t)+1): #scenario counter
              
                    #objective
                    if t<4 :
                        objective = -teta[k,t]
                    else :
                        objective = -0.125*np.lpsum((y[s1, s2, s3] - 4*w[s1, s2, s3]) for s1 in {1,2} for s2 in {1,2} for s3 in {1,2} ) + teta[k,t]
                      
                    NLDS[t,k] += objective
                    first_iteration[k,t]=LpConstraint('teta[k,t]= 0')
                    NLDS[t,k] += first_iteration
                    π[k,t]=coef[t,k].pi
                    np.status[t,k] = NLDS[t,k].solve()
                    #CHECK feasibility    
                    if LpStatus[NLDS[t,k].status(t,k)]!="Infeasible" :
                        #submodel is feasible
                        if direction=="backward" :
                            #optimal cut
                            #cut for stage befor t
                            t=t-1
                            for n in np.arange(1,(2**(t-1))+1):
                                for k in np.arange(1,(2**t)+1):
                                    σ[k,t] = opt_cut[k,t].pi 
                                    E = np.sum((p[k,t+1]/p[n,t])*np.transpose(π[k,t+1])*t[k,t] , axis=1)
                                    e = np.sum((p[k,t+1]/p[n,t])*np.transpose(π[k,t+1])*h[k,t+1]) + np.sum(np.transpose(ρ[k,t+1])+d[k,t+1])+np.sum(np.transpose(σ[k,t+1]) 
                                    
                                    #opt_cut[k,t] = first_iteration[k,t] #remove  teta[k,t]= 0
                                    opt_cut[k,t] = LpConstraint('E*np.transpose(x) + teta[k,t] >= e')
                                    NLDS[t,k] += opt_cut[k,t]
                            
                            i=i+1
                            #status(t,k) = NLDS[t,k].solve()
                        else:
                            break
                    elif LpStatus[NLDS[t,k].status(t,k)]=="Infeasible" :
                        if t>1 :                  
                            t=t-1
                            #feasiblity cut
                            ρ[k,t]=f_cut[k,t].pi
                            D[k,t]=np.transpose(π[k,t])*t[k,t-1]
                            D[k,t]=np.transpose(π[k,t])*h[k,t-1]
                            f_cut[k,t] = LpConstraint('D[k,t]*np.transpose(x)>= d[k,t]')
                            NLDS[t,k] += f_cut[k,t]
                            
                            j=j+1
                            status(t,k) = NLDS[t,k].solve()
                        else :
                            break

                    
                    #solve subproblem NLDS[t,k]
                    
                    status(t,k) = NLDS[t,k].solve()

                #end of counting scenarios
            # loop of i
        # loop of j
    if t==1 :
        direction="forward"       
        t=t+1
    elif t==4 :
        direction="backward"        
        t=t-1
    else:
        if direction=="backward" :
            direction="backward"
            t=t-1
        else:
            direction="forward"
            =t+1


    #end of defining direction  
# loop of t    
print(f"status: {model.NLDS[t,k]}, {LpStatus[NLDS[t,k].status]}")
print(f"objective: {NLDS[t,k].objective.value()}")

